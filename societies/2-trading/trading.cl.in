/**
 * Glue code to do trading.
 *
 * @author John Kloosterman
 * @date Feb. 12, 2013
 */

#pragma OPENCL EXTENSION cl_amd_printf : enable

#define _OPENCL_
#include "menu.cl"
#include "valuation.cl"

/*
 * Edge cases to watch out for:
 *  -when an agent has no units of something on the menu.
 *  -when an agent can't afford to make an optimal trade, and when
 *    the other agent can't afford the trade.
 */

float trading_utility_difference(
	uint resource_given,
	uint resource_received,
	uint resource_given_held,
	uint resource_received_held,
	uint resource_given_loss,
	uint resource_received_gain,
	__global SocietiesConfig *config
	)
{
	float resource_given_loss_utility = 
		u( resource_given_held - resource_given_loss, 
		   config->resource_D[resource_given], 
		   config->resource_n[resource_given] )
		- u( resource_given_held, 
			 config->resource_D[resource_given], 
			 config->resource_n[resource_given] );
	
	float resource_received_gain_utility = 
		u( resource_received_held + resource_received_gain, 
		   config->resource_D[resource_received], 
		   config->resource_n[resource_received] )
		- u( resource_received_held, 
			 config->resource_D[resource_received], 
			 config->resource_n[resource_received] );
	
	return resource_received_gain_utility - resource_given_loss_utility;
}

// Find the best multiple of ratio:1.
//  return a negative number if no trade is possible.
int trading_find_maximum_surplus( 
	uint num_given,
	uint num_received,
	uint giver,
	uint recipient,
	uint resource_given, // resource giver is giving up
	uint resource_received, // resource giver is receiving
	__global uint *all_resources,
	__local uint *sort_tree_scratch,  // num_threads / 2
	__local float *surpluses_scratch, // num_threads
	__global SocietiesConfig *config )
{
	// NUM_RESOURCES is a proxy for number of threads.
	int offset = 1;
	size_t local_id = get_local_id( 0 );

	// Is it faster to get only 1 thread to do this? Do we have to
	//  use global memory?
	int resource_offset = giver * CONFIG_NUM_RESOURCES;
	uint resource_given_amount = all_resources[resource_offset + resource_given];
	uint resource_received_amount = all_resources[resource_offset + resource_received];

	// Check to make sure the recipient can afford trades.
	int recipient_resource_offset = recipient * CONFIG_NUM_RESOURCES;
	uint recipient_received_amount = all_resources[recipient_resource_offset + resource_received];

/*
	printf( "Giver has %d of resource %d and %d of resource %d; recipient has %d of resource %d.\n",
			resource_given_amount,
			resource_given,
			resource_received_amount,
			resource_received,
			recipient_received_amount,
			resource_received );
*/

	int maximum_found = FALSE;
	uint max_multiplier;
	while ( !maximum_found )
	{
		// The amount of change in amount of resource1 and resource2
		float resource_given_loss = num_given * ( local_id + offset );
		float resource_received_gain = num_received * ( local_id + offset );
		
		// If we can't afford this trade, don't consider it.
		float surplus = trading_utility_difference(
			resource_given,
			resource_received,
			resource_given_amount,
			resource_received_amount,
			resource_given_loss,
			resource_received_gain,
			config );

		if ( resource_given_loss > resource_given_amount )
			surplus = -1;
		else if ( resource_received_gain > recipient_received_amount )
			surplus = -2;

		printf( "Thread ID: %d\n", local_id );
		surpluses_scratch[local_id] = surplus;
		barrier( CLK_LOCAL_MEM_FENCE );
		printf( "Surplus for thread %d: %f.\n", local_id, surplus );
		
		// Find the maximum.
		max_multiplier = max_index( surpluses_scratch, sort_tree_scratch );

		// If the maximum is the last thread, we don't know if it was the true maximum.
		//  In that case, do another round, with the last thread being reconsidered.
		if ( max_multiplier == ( CONFIG_NUM_THREADS - 1 ) )
		{
			offset += CONFIG_NUM_THREADS - 2;
			barrier( CLK_LOCAL_MEM_FENCE );
		}
		else if ( surpluses_scratch[max_multiplier] < 0 )
		{
			// The maximum was a negative number, so we can't afford any trade.
			return -1;
		}
		else
		{
			maximum_found = TRUE;
		}
	}

	return max_multiplier + offset;
}


void trading_make_trade(
	uint agent_a,
	uint agent_b,
	uint resource_a,
	uint resource_b,
	uint amount_a,
	uint amount_b,
	__global uint *all_resources
	)
{
	int agent_a_offset = ( agent_a * CONFIG_NUM_RESOURCES );
	printf( "Giver: old #%d: %d, old #%d: %d, ", 
			resource_a,
			all_resources[agent_a_offset + resource_a],
			resource_b,
			all_resources[agent_a_offset + resource_b] );
	all_resources[agent_a_offset + resource_a] -= amount_a;
	all_resources[agent_a_offset + resource_b] += amount_b;
	printf( "new #%d: %d, new #%d: %d\n", 
			resource_a,
			all_resources[agent_a_offset + resource_a],
			resource_b,
			all_resources[agent_a_offset + resource_b] );

	int agent_b_offset = ( agent_b * CONFIG_NUM_RESOURCES );
	printf( "Receiver: old #%d: %d, old #%d: %d, ", 
			resource_a,
			all_resources[agent_b_offset + resource_a],
			resource_b,
			all_resources[agent_b_offset + resource_b] );
	all_resources[agent_b_offset + resource_a] += amount_a;
	all_resources[agent_b_offset + resource_b] -= amount_b;
	printf( "new #%d: %d, new #%d: %d\n", 
			resource_a,
			all_resources[agent_b_offset + resource_a],
			resource_b,
			all_resources[agent_b_offset + resource_b] );
}

__kernel void trading(
	__global uint *all_resources,
	__global uint *random_pairs,
	__global SocietiesConfig *config
	)
{
	size_t local_id = get_local_id( 0 );
	size_t pair_id = get_global_id( 1 );
	int pair_offset = 2 * pair_id;
	uint agent_a = random_pairs[pair_offset];
	uint agent_b = random_pairs[pair_offset + 1];

	__local uint menu_a[CONFIG_MENU_SIZE];
	__local uint menu_b[CONFIG_MENU_SIZE];
	__local uint sort_tree[CONFIG_NUM_THREADS / 2];
	__local float float_scratch[CONFIG_NUM_THREADS];
	__local uint resources_scratch[CONFIG_NUM_THREADS];
	__local uchar mask_scratch[CONFIG_NUM_THREADS];

	/* How this works in the Python code:
	 (1) we generate menus
	 (2) each agent makes a list of the top num_trades possible trades from
	     the menus
	 (3) In the first round, agent a proposes trading the things it wants
	     to trade the most. Agent A proposes a number to trade, B can
		 accept or reject. If B rejects, then B proposes a number to
		 trade, and A can accept or reject.
	 (4) In the second round, B proposes trading the things it wants the most.
	 (5) In the third round, A proposes trading its second-favourite pair.
	*/

	// Generate the menus.
	menu_create_menus(
		agent_a,
		agent_b,
		all_resources,
		menu_a,
		menu_b,
		resources_scratch,
		sort_tree,
		mask_scratch,
		float_scratch,
		config
		);
	barrier( CLK_LOCAL_MEM_FENCE );

	__local uint2 agent_a_pairs[CONFIG_NUM_TRADES];
	__local uint2 agent_b_pairs[CONFIG_NUM_TRADES];

	// Compute the num_trades favourite pairs for A.
	valuation_highest_trade_valuation_pairs(
		agent_a,
		menu_a, menu_b,
		agent_a_pairs,
		all_resources,
		float_scratch,
		sort_tree,
		resources_scratch,
		mask_scratch,
		config
		);

	valuation_highest_trade_valuation_pairs(
		agent_b,
		menu_b, menu_a,
		agent_b_pairs,
		all_resources,
		float_scratch,
		sort_tree,
		resources_scratch,
		mask_scratch,
		config
		);
	barrier( CLK_LOCAL_MEM_FENCE );

	// Do the trades.
	int a_is_first_mover = TRUE;
	uint given_resource;
	uint received_resource;
	for ( int i = 0; i < ( config->num_trades * 2); i++ )
	{
		if ( local_id == 0 )
			printf( "=== Trade number %d ===\n", i );

		uint first_mover;
		uint respondent;

		int pair_id = i / 2;
		if ( a_is_first_mover )
		{
			first_mover = agent_a;
			respondent = agent_b;
			given_resource = agent_a_pairs[pair_id].x;
			received_resource = agent_a_pairs[pair_id].y;
		}
		else
		{
			first_mover = agent_b;
			respondent = agent_a;
			given_resource = agent_b_pairs[pair_id].x;
			received_resource = agent_b_pairs[pair_id].y;
		}

		if ( local_id == 0 )
		{
			printf( "Agent %d is first mover, %d respondent.\n", first_mover, respondent );

			printf( "First mover resources: " );
			int fm_offset = first_mover * CONFIG_NUM_RESOURCES;
			for ( int j = 0; j < CONFIG_NUM_RESOURCES; j++ )
				printf( "%d ", all_resources[fm_offset + j] );
			printf( "\n" );

			printf( "Respondant resources: " );
			fm_offset = respondent * CONFIG_NUM_RESOURCES;
			for ( int j = 0; j < CONFIG_NUM_RESOURCES; j++ )
				printf( "%d ", all_resources[fm_offset + j] );
			printf( "\n" );


			printf( "Trade attempting: first_mover giving %d, receiving %d.\n", given_resource, received_resource );
		}

		// Calculate agent A and B's internal valuations
		//  to see if the trade is beneficial and what
		//  the bargaining price will be.
		float first_mover_valuation;
		float respondent_valuation;
//		if ( local_id == 0 )
//		{
			first_mover_valuation = valuation_internal_valuation(
				first_mover,
				given_resource, received_resource,
				all_resources,
				config );
//		}
//		else if ( local_id == 1 )
//		{
			respondent_valuation = valuation_internal_valuation(
				respondent,
				received_resource, given_resource,
				all_resources,
				config );
//		}
//		barrier( CLK_LOCAL_MEM_FENCE );

		// Is the trade mutually beneficial? Is this the right way to compute that?
		if ( first_mover_valuation < 1
			 || respondent_valuation < 1 )
		{
			// do something
		}
		
		if ( local_id == 0 )
			printf( "Valuations: First mover: %f, Respondant: %f\n", first_mover_valuation, respondent_valuation );

		// Bargaining price is the geometric mean of
		//  Agent A and B's internal valuations.
		float f_bargaining_price = sqrt( first_mover_valuation * respondent_valuation );

		// Calculate a nearby integer ratio for the bargaining price.
		int num_given, num_received;
		if ( f_bargaining_price > 1 )
		{
			num_received = 1;
			num_given = f_bargaining_price;
		}
		else
		{
			num_received = (int) ( 1.0f / f_bargaining_price );
			// Always trade at least one, so as to never trade for nothing.
			num_given = fmax( f_bargaining_price * (float) num_received, 1.0f );
		}

		if ( local_id == 0 )
			printf( "Bargaining price: giving %d to receive %d.\n", num_given, num_received );

		// First mover optimizes its maximum surplus. We assign one thread to each
		//  multiplier of more surplus. 
		int maximum_surplus_multiplier = trading_find_maximum_surplus( 
			num_given,
			num_received,
			first_mover,
			respondent,
			given_resource,
			received_resource,
			all_resources,
			sort_tree,
			float_scratch,
			config );
		barrier( CLK_LOCAL_MEM_FENCE );

		if ( local_id == 0 )
			printf( "Maximum surplus multiplier: %d\n", maximum_surplus_multiplier );

		// Respondent accepts only if it benefits from the trade. The respondent benefits when
		//  the utility of the resources received is greater than the loss of
		//  utility of the resources given up.
		if ( maximum_surplus_multiplier > 0
			 && TRUE /* trading_respondent_benefits(...) */ )
		{
			if ( local_id == 0 )
			{
				trading_make_trade(
					first_mover,
					respondent,
					given_resource,
					received_resource,
					num_given * maximum_surplus_multiplier,
					num_received * maximum_surplus_multiplier,
					all_resources
					);
			}
		}

		// If the respondent didn't accept, the respondent gets to choose
		//  a ratio and propose it to A.

		a_is_first_mover = !a_is_first_mover;
		barrier( CLK_GLOBAL_MEM_FENCE );
	}	
}
