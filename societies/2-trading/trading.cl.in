/**
 * Glue code to do trading.
 *
 * @author John Kloosterman
 * @date Feb. 12, 2013
 */

#define _OPENCL_
#include "menu.cl"
#include "valuation.cl"

/*
 * Edge cases to watch out for:
 *  -when an agent has no units of something on the menu.
 *  -when an agent can't afford to make an optimal trade, and when
 *    the other agent can't afford the trade.
 */

float trading_utility_difference(
	uint resource_given,
	uint resource_received,
	uint resource_given_held,
	uint resource_received_held,
	uint resource_given_loss,
	uint resource_received_gain,
	__global SocietiesConfig *config
	)
{
	float resource_given_loss_utility = 
		u( resource_given_held - resource_given_loss, 
		   config->resource_D[resource_given], 
		   config->resource_n[resource_given] )
		- u( resource_given_held, 
			 config->resource_D[resource_given], 
			 config->resource_n[resource_given] );
	
	float resource_received_gain_utility = 
		u( resource_received_held + resource_received_gain, 
		   config->resource_D[resource_received], 
		   config->resource_n[resource_received] )
		- u( resource_received_held, 
			 config->resource_D[resource_received], 
			 config->resource_n[resource_received] );
	
	return resource_received_gain_utility - resource_given_loss_utility;
}

// Find the best multiple of ratio:1.
uint trading_find_maximum_surplus( 
	uint ratio,
	uint giver,
	uint recipient,
	uint resource_given, // resource giver is giving up
	uint resource_received, // resource giver is receiving
	__global uint *all_resources,
	__local uint *sort_tree_scratch,  // num_threads / 2
	__local float *surpluses_scratch, // num_threads
	__global SocietiesConfig *config )
{
	// NUM_RESOURCES is a proxy for number of threads.
	int offset = 0;
	size_t local_id = get_local_id( 0 );

	// Is it faster to get only 1 thread to do this? Do we have to
	//  use global memory?
	int resource_offset = giver * CONFIG_NUM_RESOURCES;
	uint resource_given_amount = all_resources[resource_offset + resource_given];
	uint resource_received_amount = all_resources[resource_offset + resource_received];

	// Check to make sure the recipient can afford trades.
	int recipient_resource_offset = recipient * CONFIG_NUM_RESOURCES;
	uint recipient_received_amount = all_resources[recipient_resource_offset + resource_received];

	int maximum_found = FALSE;
	uint max_multiplier;
	while ( !maximum_found )
	{
		// The amount of change in amount of resource1 and resource2
		float resource_given_loss = 1 * ( local_id + offset );
		float resource_received_gain = ratio * ( local_id + offset );
		
		// If we can't afford this trade, don't consider it.
		float surplus = trading_utility_difference(
			resource_given,
			resource_received,
			resource_given_amount,
			resource_received_amount,
			resource_given_loss,
			resource_received_gain,
			config );

		if ( resource_given_loss > resource_given_amount )
			surplus = -1;
		else if ( resource_received_gain > recipient_received_amount )
			surplus = -2;

		surpluses_scratch[local_id] = surplus;
		barrier( CLK_LOCAL_MEM_FENCE );
		printf( "Surplus for thread %d: %f.\n", local_id, surplus );
		
		// Find the maximum.
		max_multiplier = max_index( surpluses_scratch, sort_tree_scratch );

		// If the maximum is the last thread, we don't know if it was the true maximum.
		//  In that case, do another round, with the last thread being reconsidered.
		if ( max_multiplier == ( CONFIG_NUM_THREADS - 1 ) )
		{
			offset += CONFIG_NUM_THREADS - 2;
		}
		else
		{
			maximum_found = TRUE;
		}
	}

	return max_multiplier + offset;
}


void trading_make_trade(
	uint agent_a,
	uint agent_b,
	uint resource_a,
	uint resource_b,
	uint amount_a,
	uint amount_b,
	__global uint *all_resources
	)
{
	int agent_a_offset = ( agent_a * CONFIG_NUM_RESOURCES );
	all_resources[agent_a_offset + resource_a] -= amount_a;
	all_resources[agent_a_offset + resource_b] += amount_b;

	int agent_b_offset = ( agent_b * CONFIG_NUM_RESOURCES );
	all_resources[agent_b_offset + resource_a] += amount_a;
	all_resources[agent_b_offset + resource_b] -= amount_b;

	barrier( CLK_GLOBAL_MEM_FENCE );
}

__kernel void trading(
	__global uint *all_resources,
	__global uint *random_pairs,
	__global SocietiesConfig *config
	)
{
	size_t local_id = get_local_id( 0 );
	size_t pair_id = get_global_id( 1 );
	int pair_offset = 2 * pair_id;
	uint agent_a = random_pairs[pair_offset];
	uint agent_b = random_pairs[pair_offset + 1];

	__local uint menu_1[CONFIG_MENU_SIZE];
	__local uint menu_2[CONFIG_MENU_SIZE];
	__local uint sort_tree[CONFIG_NUM_THREADS / 2];
	__local float float_scratch[CONFIG_NUM_THREADS];
	__local uint resources_scratch[CONFIG_NUM_THREADS];
	__local uchar mask_scratch[CONFIG_NUM_THREADS];

	/// @XXX: maybe after this point, to avoid confusion, rename the agents
	///  "first mover" and "respondent".
	int a_is_first_mover = TRUE;
	for ( int i = 0; i < ( config->num_trades * 2); i++ )
	{
		if ( local_id == 0 )
			printf( "=== Trade number %d ===\n", i );

		uint first_mover;
		uint respondent;

		if ( a_is_first_mover )
		{
			first_mover = agent_a;
			respondent = agent_b;
		}
		else
		{
			first_mover = agent_b;
			respondent = agent_a;
		}

		if ( local_id == 0 )
			printf( "Agent %d is first mover, %d respondent.\n", first_mover, respondent );

		// Generate the menus.
		menu_create_menus(
			first_mover,
			respondent,
			all_resources,
			menu_1,
			menu_2,
			resources_scratch,
			sort_tree,
			mask_scratch,
			float_scratch,
			config
			);
		barrier( CLK_LOCAL_MEM_FENCE );

		__local uint resource_1, resource_2;
		// The first mover gets to choose its favourite pair.
		valuation_highest_trade_valuation(
			first_mover,
			menu_1, menu_2,
			&resource_1, &resource_2,
			all_resources,
			float_scratch,
			sort_tree,
			config
			);
		barrier( CLK_LOCAL_MEM_FENCE );

		if ( local_id == 0 )
			printf( "Trade attempting: first_mover giving %d, receiving %d.\n", resource_1, resource_2 );

		// Calculate agent A and B's internal valuations
		//  to see if the trade is beneficial and what
		//  the bargaining price will be.
		__local float first_mover_valuation;
		__local float respondent_valuation;
		if ( local_id == 0 )
		{
			first_mover_valuation = valuation_internal_valuation(
				first_mover,
				resource_1, resource_2,
				all_resources,
				config );
		}
		else if ( local_id == 1 )
		{
			respondent_valuation = valuation_internal_valuation(
				respondent,
				resource_2, resource_1,
				all_resources,
				config );
		}
		barrier( CLK_LOCAL_MEM_FENCE );

		// Is the trade mutually beneficial? Is this the right way to compute that?
		if ( first_mover_valuation < 1
			 || respondent_valuation < 1 )
		{
			// do something
		}
		
		if ( local_id == 0 )
			printf( "Valuations: First mover: %f, Respondant: %f\n", first_mover_valuation, respondent_valuation );

		// Bargaining price is the geometric mean of
		//  Agent A and B's internal valuations.
		float f_bargaining_price = sqrt( first_mover_valuation * respondent_valuation );
		// Since resources are possessed in integers, this gets
		//  rounded to nearest integer.
		int bargaining_price = (int) f_bargaining_price;

		if ( local_id == 0 )
			printf( "Bargaining price: %f %d.\n", f_bargaining_price, bargaining_price );

		/// @XXX: we don't consider what B can afford when we find maximum
		/// surplus.

		// First mover optimizes its maximum surplus. We assign one thread to each
		//  multiplier of more surplus. 
		uint maximum_surplus_multiplier = trading_find_maximum_surplus( 
			bargaining_price,
			first_mover,
			respondent,
			resource_1,
			resource_2,
			all_resources,
			sort_tree,
			float_scratch,
			config );
		barrier( CLK_LOCAL_MEM_FENCE );

		if ( local_id == 0 )
			printf( "Maximum surplus multiplier: %d\n", maximum_surplus_multiplier );

		// Respondent accepts only if it benefits from the trade. The respondent benefits when
		//  the utility of the resources received is greater than the loss of
		//  utility of the resources given up.
		if ( TRUE /* trading_respondent_benefits(...) */ )
		{
			trading_make_trade(
				first_mover,
				respondent,
				resource_1,
				resource_2,
				bargaining_price * maximum_surplus_multiplier,
				maximum_surplus_multiplier,
				all_resources
				);
		}

		a_is_first_mover = !a_is_first_mover;
	}	
}
