#define _OPENCL_
#include "board.c"
#include "tree_array.c"
#include "depths.h"

/*
 * Plan:
 *  (a) generate all the boards. This can be done in log(n) time, if correct.
 *  (b) evaluate the leaf nodes. (~16 at once, using atomic writes)
 *  (c) perform minimax.
 *
 * I don't think local memory is persistent across kernel executions, so
 *  we probably have to do this all at once.
 */

/*
 * We will eventually want a special packed board structure because memory is our
 *  bottleneck.
 */

/*
 * Layout of board_array:
 *
 * [  tree 0   ][ tree 1 ]...[ tree n-1 ]
 *
 * Due to a theorem (https://ece.uwaterloo.ca/~dwharder/aads/LectureMaterials/4.07.NaryTrees.pdf),
 *  there are ( N^(k+1) - 1 ) / ( N - 1 ) nodes in a complete N-ary tree.
 *
 * Dimensions:
 *  (tree) x (board) x (board_component)
 *   (n)   x  216 leaf nodes x 14 components = 3024n threads.
 */

// Bug: if the game ends after the sequential step but before the GPU evaluation level,
//   then the score is wonky.

// The number of layers, including the root and bottom layers.

int tree_size ( void )
{
	return tree_array_size( 6, PARALLEL_DEPTH - 1 );
}

int leaf_start ( void )
{
	return tree_array_size( 6, PARALLEL_DEPTH - 2 );
}

void add_evaluate_board( volatile __global int *evaluate_boards, int board )
{
//	if ( evaluate_boards[0] < 100 )
//		printf( "Adding board %d\n", board );

	int array_idx = atomic_inc( &evaluate_boards[0] ) + 1;
	evaluate_boards[array_idx] = board;
}


__kernel void zero_evaluate_board( global int *evaluate_boards )
{
	evaluate_boards[0] = 0;
}


// (a) generate the boards in log(n) time.
// Note that to do this in parallel, every thread must be in the same local
//  group for the synchronization to work.
// AMD OpenCL allows only 256 work-items per work-group, so we are limited
//  to a depth of 3 with this approach (when there will be 216 leaf nodes).

// global: tree x (216)
// local: 1 x 216
__kernel void opencl_player( __global Board *host_start )
{
	// does this need a literal size? Probably.
	__local Board board_array[258];

	int tree = get_global_id( 0 );
	int local_id = get_local_id( 1 );
	int move = local_id % 6;
	int move_offset;

	// If this whole tree isn't meaningful, don't do anything.
	if ( !host_start[tree].legal_move )
		return;

	// Put in the root node.
	if ( get_global_id( 1 ) == 0 )
	{
		board_array[0] = host_start[tree];
	}
	barrier( CLK_LOCAL_MEM_FENCE );

	Board m_board;
	int power_of_six = 6;
	int level_start = 1;
	for ( int i = 1; i < PARALLEL_DEPTH; i++ )
	{
		if ( local_id < power_of_six )
		{
			// Integer division rounds down.
			int parent = tree_array_parent( 6, level_start + local_id );
			m_board = board_array[parent];

			// Calculate the move offset based on whose turn it is.
			if ( m_board.player_to_move == TOP )
				move_offset = 7;
			else
				move_offset = 0;

			// Make the move.
			if ( m_board.legal_move 
				 && board_legal_move( &m_board, move + move_offset ) )
			{
				board_make_move( &m_board, move + move_offset );

				// If we are at the bottom of the tree, this is a leaf node.
/*
				if ( i == ( PARALLEL_DEPTH - 1 ) )
				{
//					printf( "Adding leaf!\n" );
					add_evaluate_board( evaluate_boards, ree_offset + level_start + local_id );
				}
				// Or if the game is newly over. This won't add children of game-over boards because
				//  m_board.legal_move would have been false.
				else if ( board_game_over( &m_board ) )
				{
//					printf( "Adding game over!\n" );
					add_evaluate_board( evaluate_boards, tree_offset + level_start + local_id );
					m_board.legal_move = FALSE;
				}
*/


			}
/*
			else
			{
				// Set m_board.legal_move to FALSE, but just by copying the board,
				//  this is the case.

				// Don't bother copying all the memory, just what we want.
				board_array[tree_offset + level_start + local_id].legal_move = FALSE;
			}
*/
			board_array[level_start + local_id] = m_board;

		}

		level_start += power_of_six;
		power_of_six *= 6;

		barrier( CLK_LOCAL_MEM_FENCE );
	}

	// Evaluate boards.
	int weight;
	for ( int i = 0; i < 14; i++ )
	{
		if ( i == 6 || i == 13 )
			weight = 5;
		else
			weight = 1;

		board_array[local_id].score += board_array[local_id].board[i] * weight;
	}
	barrier( CLK_LOCAL_MEM_FENCE );

	// Minimax
	power_of_six = (int) pow( 6.0f, PARALLEL_DEPTH - 2 );
	level_start = leaf_start();

	for ( int i = PARALLEL_DEPTH - 2; i >= 0; i-- )
	{
		level_start -= power_of_six;

//		printf( "level_start: %d, power_of_six: %d\n", level_start, power_of_six );
		if ( local_id < power_of_six )
		{
			// The board in board_array.
			int board_offset = level_start + local_id;
			int child_offset = tree_array_first_child( 6, board_offset );
			PlayerPosition playerToMove;
			int score;

			playerToMove = board_array[board_offset].player_to_move;
			if ( playerToMove == TOP )
				score = INT_MIN;
			else
				score = INT_MAX;
			
//			printf( "Parent offset: %d, child offset: %d, tree offset: %d\n", board_offset, child_offset, tree_offset );
			
			int has_legal_move = FALSE;
			for ( int i = 0; i < 6; i++ )
			{
				Board child = board_array[child_offset + i];
				if ( child.legal_move 
					 && ( ( playerToMove == TOP && child.score > score )
						  || ( playerToMove == BOTTOM && child.score < score ) ) )
				{
					has_legal_move = TRUE;
					score = child.score;
				}
			}
			
			if ( has_legal_move )
				board_array[board_offset].score = score;
			// else leave it with the evaluated score.
		}

		power_of_six /= 6;
		barrier( CLK_LOCAL_MEM_FENCE );
	}

	// Store back in global memory.
	host_start[tree].score = board_array[0].score;
}


#if 0
// Don't use local work size at all for this kernel.
// remember: tree x board x component
//
// @XXX: precondition: score = 0 for all boards!
__kernel void evaluate_board( __global int *evaluate_boards, __global Board *board_array )
{
	// The index of our board in board_array
	int offset = evaluate_boards[ get_global_id( 0 ) + 1 ];

	// Kalahs count 5 times as much.
	int weight = 1;
	int board_space = get_global_id( 1 );
	if ( board_space == 6
		 || board_space == 13 )
		weight = 5;
		
	if ( board_space < 7 )
		weight = -weight;

	atomic_add( &board_array[offset].score, weight * board_array[offset].board[board_space] );
}

// almost exactly like the first one.
//  dimensions: tree x board
//  We only will use the # of threads of the l
//
// Strategies: use fewer threads, with a loop -> choose this one, because fewer global memory accesses.
//  use more threads, with an atomic min/max.
__kernel void minimax( __global Board *board_array )
{
//	printf( "global id: %d %d\n", get_global_id( 0 ), get_global_id( 1 ) );

	int tree = get_global_id( 0 );
	int tree_offset = tree_size() * tree;
	int local_id = get_global_id( 1 );

	int power_of_six = (int) pow( 6.0f, PARALLEL_DEPTH - 2 );
	int level_start = leaf_start();

	for ( int i = PARALLEL_DEPTH - 2; i >= 0; i-- )
	{
		level_start -= power_of_six;

//		printf( "level_start: %d, power_of_six: %d\n", level_start, power_of_six );
		if ( local_id < power_of_six )
		{
			// The board in board_array.
			int board_offset = level_start + get_global_id( 1 );
			int child_offset = tree_array_first_child( 6, board_offset );
			PlayerPosition playerToMove;
			int score;

			playerToMove = board_array[tree_offset + board_offset].player_to_move;
			if ( playerToMove == TOP )
				score = INT_MIN;
			else
				score = INT_MAX;
			
//			printf( "Parent offset: %d, child offset: %d, tree offset: %d\n", board_offset, child_offset, tree_offset );
			
			int has_legal_move = FALSE;
			for ( int i = 0; i < 6; i++ )
			{
				Board child = board_array[tree_offset + child_offset + i];
				if ( child.legal_move 
					 && ( ( playerToMove == TOP && child.score > score )
						  || ( playerToMove == BOTTOM && child.score < score ) ) )
				{
					has_legal_move = TRUE;
					score = child.score;
				}
			}
			
			if ( has_legal_move )
				board_array[tree_offset + board_offset].score = score;
			// else leave it with the evaluated score.
		}

		power_of_six /= 6;
		barrier( CLK_GLOBAL_MEM_FENCE );
	}
}

__kernel void get_results( __global Board *host_start, __global Board *board_array )
{
	int tree = get_global_id( 0 );
	int tree_offset = tree_size() * ( tree /* % WORKGROUP_SIZE */ );

	host_start[tree].score = board_array[tree_offset].score;
}
#endif
