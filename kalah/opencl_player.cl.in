#define _OPENCL_
#include "board.c"
#include "tree_array.c"
#include "depths.h"

/*
 * Plan:
 *  (a) generate all the boards. This can be done in log(n) time, if correct.
 *  (b) evaluate the leaf nodes. (~16 at once, using atomic writes)
 *  (c) perform minimax.
 *
 * I don't think local memory is persistent across kernel executions, so
 *  we probably have to do this all at once.
 */

/*
 * We will eventually want a special packed board structure because memory is our
 *  bottleneck.
 */

/*
 * Layout of board_array:
 *
 * [  tree 0   ][ tree 1 ]...[ tree n-1 ]
 *
 * Due to a theorem (https://ece.uwaterloo.ca/~dwharder/aads/LectureMaterials/4.07.NaryTrees.pdf),
 *  there are ( N^(k+1) - 1 ) / ( N - 1 ) nodes in a complete N-ary tree.
 *
 * Dimensions:
 *  (tree) x (board) x (board_component)
 *   (n)   x  216 leaf nodes x 14 components = 3024n threads.
 */

// Bug: if the game ends after the sequential step but before the GPU evaluation level,
//   then the score is wonky.

// The number of layers, including the root and bottom layers.

int tree_size ( void )
{
	return tree_array_size( 6, PARALLEL_DEPTH - 1 );
}

int leaf_start ( void )
{
	return tree_array_size( 6, PARALLEL_DEPTH - 2 );
}

// (a) generate the boards in log(n) time.
// Note that to do this in parallel, every thread must be in the same local
//  group for the synchronization to work.
// AMD OpenCL allows only 256 work-items per work-group, so we are limited
//  to a depth of 3 with this approach (when there will be 216 leaf nodes).

void evaluate_board( int board, __local Board *board_array )
{
/*	int weight;

	for ( int i = 0; i < 14; i++ )
	{
		if ( i == 6 || i == 13 )
			weight = 5;
		else
			weight = 1;

		if ( i < 7 )
			weight = -weight;

		board_array[board].score += board_array[board].board[i] * weight;
	}
*/

	board_array[board].score = board_array[board].board[13] - board_array[board].board[6];
}

int get_real_local_id( void )
{
	return 6 * get_local_id( 1 ) + get_local_id( 2 );
}

void generate_boards( __global Board *host_start, __local Board *board_array )
{
	int tree = get_global_id( 0 );
	int local_id = get_local_id( 1 );
	int move = local_id % 6;
	int move_offset;

	// Put in the root node.
	if ( local_id == 0 )
	{
		board_array[0] = host_start[tree];
	}
	barrier( CLK_LOCAL_MEM_FENCE );

	Board m_board;
	int power_of_six = 6;
	int level_start = 1;
	for ( int i = 1; i < PARALLEL_DEPTH + 1; i++ )
	{
		if ( local_id < power_of_six )
		{
			// Integer division rounds down.
			int parent = tree_array_parent( 6, level_start + local_id );
			m_board = board_array[parent];

			// Calculate the move offset based on whose turn it is.
			if ( m_board.player_to_move == TOP )
				move_offset = 7;
			else
				move_offset = 0;

			// Make the move.
			if ( m_board.legal_move 
				 && board_legal_move( &m_board, move + move_offset ) )
			{
				board_make_move( &m_board, move + move_offset );
			}
			else
			{
				m_board.legal_move = FALSE;
			}

			board_array[level_start + local_id] = m_board;
		}

		level_start += power_of_six;
		power_of_six *= 6;

		barrier( CLK_LOCAL_MEM_FENCE );
	}
}

__kernel void generate_boards_test( __global Board *start_board, __global Board *host_board_array )
{
	__local Board board_array[259];
	int local_id = get_local_id( 1 );

	generate_boards( start_board, board_array );
	barrier( CLK_LOCAL_MEM_FENCE );

	// Copy from local to global mem.
	host_board_array[local_id] = board_array[local_id];

	if ( local_id < 43 )
		host_board_array[local_id + 216] = board_array[local_id + 216];
}

void evaluate_boards( __local Board *board_array )
{
	int local_id = get_local_id( 1 );

	// Evaluate boards.
	evaluate_board( local_id, board_array);

	if ( local_id < 43 )
		evaluate_board( local_id + 216, board_array );
}

__kernel void evaluate_boards_test( __global Board *host_board_array )
{
	__local Board board_array[259];
	int local_id = get_local_id( 1 );

	board_array[local_id] = host_board_array[local_id];
	if ( local_id < 43 )
		board_array[local_id + 216] = host_board_array[local_id + 216];
	barrier( CLK_LOCAL_MEM_FENCE );

	evaluate_boards( board_array );
	barrier( CLK_LOCAL_MEM_FENCE );

	host_board_array[local_id] = board_array[local_id];

	if ( local_id < 43 )
		host_board_array[local_id + 216] = board_array[local_id + 216];
}

void minimax( __local Board *board_array )
{
	// Minimax
	int power_of_six = (int) pow( 6.0f, PARALLEL_DEPTH - 2 );
	int level_start = leaf_start();
	int local_id = get_real_local_id();

	for ( int i = PARALLEL_DEPTH - 2; i >= 0; i-- )
	{
		level_start -= power_of_six;
		if ( local_id < power_of_six )
		{
			// The board in board_array.
			int board_offset = level_start + local_id;
			int child_offset = tree_array_first_child( 6, board_offset );
			PlayerPosition playerToMove;
			int score;

			playerToMove = board_array[board_offset].player_to_move;
			if ( playerToMove == TOP )
				score = INT_MIN;
			else
				score = INT_MAX;
			
			int has_legal_move = FALSE;
			for ( int i = 0; i < 6; i++ )
			{
				Board child = board_array[child_offset + i];
				if ( child.legal_move 
					 && ( ( playerToMove == TOP && child.score > score )
						  || ( playerToMove == BOTTOM && child.score < score ) ) )
				{
					has_legal_move = TRUE;
					score = child.score;
				}
			}
			
			if ( has_legal_move )
				board_array[board_offset].score = score;
			// else leave it with the evaluated score.
		}

		power_of_six /= 6;
		barrier( CLK_LOCAL_MEM_FENCE );
	}
}

// global: tree x (216)
// local: 1 x 216
__kernel void opencl_player( __global Board *host_start )
{
	int tree = get_global_id( 0 );

	// does this need a literal size? Probably.
	__local Board board_array[259];

	// If this whole tree isn't meaningful, don't do anything.
	if ( !host_start[tree].legal_move )
		return;

	generate_boards( host_start, board_array );

	evaluate_boards( board_array );
	barrier( CLK_LOCAL_MEM_FENCE );

	minimax( board_array );

	// Store back in global memory.
	if ( get_real_local_id() == 0 )
		host_start[tree].score = board_array[0].score;
}
