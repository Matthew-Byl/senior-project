#pragma OPENCL EXTENSION cl_amd_printf : enable
#define NUM_CHANNELS 4
#include "objects.h"

float3 get_ray_direction( size_t x, size_t num_x, size_t y, size_t num_y )
{
	float xFrac = (float) x / (float) num_x;
	float yFrac = (float) y / (float) num_y;

	float3 direction = (float3)( 1.0, -(xFrac - 0.5), -(yFrac - 0.5) );
	return normalize( direction );
}

void set_pixel( __global uchar4 *pixbuf, uchar r, uchar g, uchar b )
{
	size_t x = get_global_id( 0 );
	size_t y = get_global_id( 1 );
	size_t num_x = get_global_size( 0 );

	__global uchar4 *pixel = pixbuf + ( y * num_x ) + x;
	(*pixel).x = r;
	(*pixel).y = g;
	(*pixel).z = b;
	(*pixel).w = 255;
}

float sphere_get_distance(
	float3 camera_position,
	float3 camera_direction,
	float3 *normal,
	Object object )
{
	// v = camera_position - sphere_position;
	float3 v = camera_position - object.position;
	float v_dot_d = dot( v, camera_direction );
	
	float r = object.objects.sphere.radius;

	// I don't know if this is correct or not.
	float v_len = length( v );
	float discriminant = ( v_dot_d * v_dot_d ) - ( ( v_len * v_len ) - ( r * r ) );
	
	// No intersection.
	if ( discriminant < 0 )
	{
		return -1;
	}

	float intersect_1 = -v_dot_d + sqrt( discriminant );
	float intersect_2 = -v_dot_d - sqrt( discriminant );
	float min_intersect = min( intersect_1, intersect_2 );

	float3 intersection_point = camera_position + ( min_intersect * camera_direction );

	*normal = intersection_point - object.position / 
		fabs( intersection_point - object.position );

	return distance( camera_position, intersection_point );
}

float plane_get_distance(
	float3 camera_position,
	float3 camera_direction,
	float3 *normal,
	Object object )
{
	// point on the plane:
	float3 point = object.position;
	float3 p_normal = object.objects.plane.normal;

//	printf( "P_Normal: %f %f %f\n", p_normal.x, p_normal.y, p_normal.z );

//	float numerator = dot( point - camera_position, p_normal );
//	float numerator = dot( point, p_normal) + dot( camera_position, p_normal );
//	float denominator = dot( camera_direction, p_normal );

	float numerator = dot( camera_position, p_normal );
	float denominator = -dot( p_normal, camera_direction );

	// If either numerator or denominator 0, then we either
	//  never intersect or always intersect the plane, so
	//  don't show it.
	if ( numerator == 0 || denominator == 0 )
		return -1;
	
	if ( ( numerator / denominator ) < 0 )
		return -1;

	float3 position = 
		camera_position 
		+ ( ( numerator / denominator) * camera_direction );

//	printf( "Intersection: %f %f %f\n", position.x, position.y, position.z );

	*normal = p_normal;
	return distance( camera_position, position );
}

float get_distance( 
	float3 camera_position,
	float3 camera_direction,
	float3 *normal,
	Object object )
{
	if ( object.type == SPHERE_TYPE )
	{
		return sphere_get_distance(
			camera_position,
			camera_direction,
			normal,
			object
		);
	}
	else if ( object.type == PLANE_TYPE )
	{
		return plane_get_distance(
			camera_position,
			camera_direction,
			normal,
			object
		);
	}

	return -1;
}

// Returns index of closest object, or -1 if none;
int closest_object( 
	float3 camera_position,
	float3 camera_direction,
	int num_objects,
	float *distance,
	float3 *normal,
	__global Object *world )
{
	float min_distance = 1000000000;
	int min_object = -1;

	for ( int i = 0; i < num_objects; i++ )
	{
		float distance = get_distance(
			camera_position,
			camera_direction,
			normal,
			world[i]
		);

		if ( distance > 0
			 && distance < min_distance )
		{
			min_distance = distance;
			min_object = i;
		}
	}

	*distance = min_distance;
	return min_object;
}

// Shadows, specular, ambient, diffuse, etc.
#define L_AMBIENT 0.5
uchar3 compute_lighting( float3 position, float3 normal, uchar3 colour, float distance )
{
	float distance_factor = 0.1 * distance;
	if ( distance_factor > 1 )
		distance_factor = 1;
	float3 fog = (float3)( 128, 128, 128 ) * distance_factor;

	float3 f_ambient;
	f_ambient.x = L_AMBIENT * (float) colour.x * distance_factor;
	f_ambient.y = L_AMBIENT * (float) colour.y * distance_factor;
	f_ambient.z = L_AMBIENT * (float) colour.z * distance_factor;

	f_ambient += fog;

	return (uchar3)( f_ambient.x, f_ambient.y, f_ambient.z );
}


float3 sphere_get_normal(
	float3 camera_position,
	float3 camera_direction,
	Object object )
{
	return ( float3 )( 0, 0, 0 );
}

float3 get_normal(
	float3 camera_position,
	float3 camera_direction,
	Object object )
{
	return ( float3 )( 0, 0, 0 );
}	

__kernel void raytrace( 
	__global uchar4 *pixbuf,
	__global Object *objects,
	__global Light *lights,
	__global float3 *camera_position )
//	__global float3 *camera_position,
//	__global int *num_objects,
{
	int num_objects = 3;

	// Get information about our relative position.
	size_t x = get_global_id( 0 );
	size_t y = get_global_id( 1 );
	size_t num_x = get_global_size( 0 );
	size_t num_y = get_global_size( 1 );	

	float3 camera_direction = get_ray_direction( x, num_x, y, num_y );
	float distance;
	float3 normal;
	int closest = closest_object( 
		*camera_position,
		camera_direction,
		num_objects,
		&distance,
		&normal,
		objects
	);

	if ( closest == -1 )
	{
		set_pixel( pixbuf, 0, 0, 0 );
	}
	else
	{
		uchar3 colour = compute_lighting(
			objects[closest].position,
			normal,
			objects[closest].colour,
			distance
		);

		set_pixel( pixbuf, colour.x, colour.y, colour.z );
	}
}
