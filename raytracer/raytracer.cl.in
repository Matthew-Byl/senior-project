#pragma OPENCL EXTENSION cl_amd_printf : enable
#define NUM_CHANNELS 4
#include "objects.h"

float3 get_ray_direction( size_t x, size_t num_x, size_t y, size_t num_y )
{
	float xFrac = (float) x / (float) num_x;
	float yFrac = (float) y / (float) num_y;

	float3 direction = (float3)( 1.0, -(xFrac - 0.5), -(yFrac - 0.5) );
	return normalize( direction );
}

void set_pixel( __global uchar4 *pixbuf, uchar r, uchar g, uchar b )
{
	size_t x = get_global_id( 0 );
	size_t y = get_global_id( 1 );
	size_t num_x = get_global_size( 0 );

	__global uchar4 *pixel = pixbuf + ( y * num_x ) + x;
	(*pixel).x = r;
	(*pixel).y = g;
	(*pixel).z = b;
	(*pixel).w = 255;
}

float sphere_get_distance(
	float3 camera_position,
	float3 camera_direction,
	float3 *normal,
	float3 *intersect,
	Object object )
{
	// v = camera_position - sphere_position;
	float3 v = camera_position - object.position;
	float v_dot_d = dot( v, camera_direction );
	
	float r = object.objects.sphere.radius;

	// I don't know if this is correct or not.
	float v_len = length( v );
	float discriminant = ( v_dot_d * v_dot_d ) - ( ( v_len * v_len ) - ( r * r ) );
	
	// No intersection.
	if ( discriminant < 0 )
	{
		return -1;
	}

	float intersect_1 = -v_dot_d + sqrt( discriminant );
	float intersect_2 = -v_dot_d - sqrt( discriminant );
	float min_intersect = min( intersect_1, intersect_2 );

	// It is behind us.
	if ( min_intersect < 0 )
		return -1;

	float3 intersection_point = camera_position + ( min_intersect * camera_direction );

	// Is there a divide-by-zero?
	*normal = intersection_point - object.position / 
		fabs( intersection_point - object.position );
	*intersect = intersection_point;

	return distance( camera_position, intersection_point );
}

float plane_get_distance(
	float3 camera_position,
	float3 camera_direction,
	float3 *normal,
	float3 *intersect,
	Object object )
{
	// point on the plane:
	float3 point = object.position;
	float3 p_normal = object.objects.plane.normal;

//	printf( "P_Normal: %f %f %f\n", p_normal.x, p_normal.y, p_normal.z );

	float numerator = dot( point - camera_position, p_normal );
	float denominator = dot( camera_direction, p_normal );

//	float numerator = dot( point, p_normal) + dot( camera_position, p_normal );
//	float denominator = dot( camera_direction, p_normal );

//	float numerator = dot( camera_position, p_normal );
//	float denominator = -dot( p_normal, camera_direction );

	// If either numerator or denominator 0, then we either
	//  never intersect or always intersect the plane, so
	//  don't show it.
	if ( numerator == 0 || denominator == 0 )
		return -1;
	
	if ( ( numerator / denominator ) < 0 )
		return -1;

	float3 position = 
		camera_position 
		+ ( ( numerator / denominator) * camera_direction );

//	printf( "Intersection: %f %f %f\n", position.x, position.y, position.z );
	
	*intersect = position;
	*normal = p_normal;
	return distance( camera_position, position );
}

float get_distance( 
	float3 camera_position,
	float3 camera_direction,
	float3 *normal,
	float3 *intersect,
	Object object )
{
	if ( object.type == SPHERE_TYPE )
	{
		return sphere_get_distance(
			camera_position,
			camera_direction,
			normal,
			intersect,
			object
		);
	}
	else if ( object.type == PLANE_TYPE )
	{
		return plane_get_distance(
			camera_position,
			camera_direction,
			normal,
			intersect,
			object
		);
	}

	return -1;
}

// Returns index of closest object, or -1 if none;
int closest_object( 
	float3 camera_position,
	float3 camera_direction,
	int num_objects,
	float *distance,
	float3 *normal,
	float3 *intersect,
	__global Object *world )
{
	float min_distance = 1000000000;
	int min_object = -1;
	float3 min_normal;

	for ( int i = 0; i < num_objects; i++ )
	{
		float3 normal_t;
		float distance = get_distance(
			camera_position,
			camera_direction,
			&normal_t,
			intersect,
			world[i]
		);

		if ( distance > 0
			 && distance < min_distance )
		{
			min_distance = distance;
			min_object = i;
			min_normal = normal_t;
		}
	}

	*normal = min_normal;
	*distance = min_distance;
	return min_object;
}

// Shadows, specular, ambient, diffuse, etc.
#define L_AMBIENT 0.5f
#define DIFFUSE_ATTENUATION 2.0f
uchar3 compute_lighting( 
	__global Light *lights, 
	int num_lights,
	float3 camera_position,
	float3 camera_direction,
	float3 position, 
	float3 normal, 
	uchar3 colour, 
	float object_distance )
{
	float3 f_colour;
	f_colour.x = (float) colour.x;
	f_colour.y = (float) colour.y;
	f_colour.z = (float) colour.z;

	// Fog
	float distance_factor = 0.05 * object_distance;
	if ( distance_factor > 1 )
		distance_factor = 1;
	float3 fog = (float3)( 128, 128, 128 ) * distance_factor;

	// Ambient
	float3 f_ambient = L_AMBIENT * f_colour;

	// Diffuse
	float3 f_diffuse = (float3)(0,0,0);
	for ( int i = 0; i < num_lights; i++ )
	{
		// TODO: See whether light blocked.

		float light_distance = fabs( distance( position, lights[i].position ) );
		float3 light_vector = position - lights[i].position;

		float angle = dot( light_vector, normal );

		f_diffuse += f_colour * angle
			* pow( 1 / light_distance, DIFFUSE_ATTENUATION );
	}
	
//	float3 light = f_ambient + f_diffuse - fog;
	float3 light = f_ambient + f_diffuse;

	float3 clamped_light = fmin( light, (float3)( 255, 255, 255 ) );

	return (uchar3)( clamped_light.x, clamped_light.y, clamped_light.z );
}

__kernel void raytrace( 
	__global uchar4 *pixbuf,
	__global Object *objects,
	__global Light *lights,
	__global float3 *camera_position,
	__global int *num_objects )
//	__global float3 *camera_position,
//	__global int *num_objects,
{
	// Get information about our relative position.
	size_t x = get_global_id( 0 );
	size_t y = get_global_id( 1 );
	size_t num_x = get_global_size( 0 );
	size_t num_y = get_global_size( 1 );	

	float3 camera_direction = get_ray_direction( x, num_x, y, num_y );
	float distance;
	float3 normal;
	float3 intersect;
	int closest = closest_object( 
		*camera_position,
		camera_direction,
		*num_objects,
		&distance,
		&normal,
		&intersect,
		objects
	);

	if ( closest == -1 )
	{
		set_pixel( pixbuf, 0, 0, 0 );
	}
	else
	{
		uchar3 colour = compute_lighting(
			lights,
			1,
			*camera_position,
			camera_direction,
			intersect,
			normal,
			objects[closest].colour,
			distance
		);

		set_pixel( pixbuf, colour.x, colour.y, colour.z );
	}
}
